<script is:inline>
  (() => {
    const root = document.documentElement;
    const $ = (sel) => document.querySelector(sel);

    // iOS: always use WebP background (no freeze, no taps, no switching logic)
    const ua = navigator.userAgent || "";
    const isIOS = /iPhone|iPad|iPod/i.test(ua);
    if (isIOS) document.body.classList.add("is-ios");

    const isStudyTrigger = (el) => {
      const v = el.getAttribute("data-study") || "";
      let val = v;
      try { val = decodeURIComponent(val); } catch {}
      val = val.trim().toLowerCase();
      return val.startsWith("study:") && val.includes("[//");
    };

    const isBackTrigger = (el) => {
      const txt = (el.textContent || "").trim().toLowerCase();
      return txt === "<- back" || txt === "â† back" || txt === "back";
    };

    const cssNum = (name, fallback) => {
      const raw = getComputedStyle(root).getPropertyValue(name).trim();
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallback;
    };

    const cssMs = (name, fallback) => {
      const raw = getComputedStyle(root).getPropertyValue(name).trim();
      const n = parseFloat(raw);
      return Number.isFinite(n) ? n : fallback;
    };

    const updateConnectorWidth = () => {
      const tl = $(".corner-plus.tl");
      if (!tl) return;
      const fs = parseFloat(getComputedStyle(tl).fontSize) || 28;
      const w = Math.max(2, Math.round(fs * 0.10));
      root.style.setProperty("--connector-width", `${w}px`);
    };

    const setConnectorMetrics = () => {
      const tl = $(".corner-plus.tl");
      const bl = $(".corner-plus.bl");
      const conn = $(".left-connector");
      if (!tl || !bl || !conn) return;

      const rTL = tl.getBoundingClientRect();
      const rBL = bl.getBoundingClientRect();

      const cx = rTL.left + rTL.width / 2;

      const gap = cssNum("--connector-gap", 14);
      const topY = (rTL.bottom + gap);
      const bottomY = (rBL.top - gap);
      const h = Math.max(0, bottomY - topY);
      const cy = topY + (h / 2);

      conn.style.left = `${cx}px`;
      conn.style.top = `${cy}px`;
      conn.style.height = `${h}px`;
    };

    // background blur toggles
    const blurBG = () => document.body.classList.add("bg-blur");
    const unblurBG = () => document.body.classList.remove("bg-blur");

    // NEW: brandyura fade toggles (targets #logo if present)
    const fadeLogo = () => document.body.classList.add("logo-fade");
    const unfadeLogo = () => document.body.classList.remove("logo-fade");

    const merge = () => {
      if (document.body.classList.contains("plus-merged")) return;

      updateConnectorWidth();
      setConnectorMetrics();

      document.body.classList.remove("plus-merged");
      void document.body.offsetWidth;

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          document.body.classList.add("plus-merged");
        });
      });
    };

    const unmerge = () => {
      document.body.classList.remove("plus-merged");
    };

    const animateStudyListCascade = () => {
      const items = Array.from(document.querySelectorAll("[data-study]"))
        .filter((el) => el instanceof HTMLElement && isStudyTrigger(el));

      if (!items.length) return false;

      const stagger = cssNum("--cascade-stagger", 80);
      const ms = cssNum("--cascade-ms", 420);

      items.forEach((el, i) => {
        el.style.animation = "none";
        el.style.opacity = String(cssNum("--cascade-from-opacity", 0.25));
        el.style.transform = `translateY(${cssNum("--cascade-from-y", -10)}px)`;
        el.style.filter = `blur(${cssNum("--cascade-from-blur", 1)}px)`;

        void el.offsetWidth;

        const delay = i * stagger;
        el.style.animation = `studyCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

        el.addEventListener("animationend", () => {
          el.style.filter = "blur(0)";
        }, { once: true });
      });

      return true;
    };

    let didIntroCascade = false;

    const runIntroCascade = () => {
      if (didIntroCascade) return false;

      const items = Array.from(document.querySelectorAll("[data-intro-cascade]"))
        .filter((el) => el instanceof HTMLElement);

      if (!items.length) return false;

      didIntroCascade = true;

      const stagger = cssNum("--intro-cascade-stagger", 90);
      const ms = cssNum("--intro-cascade-ms", 520);

      items.forEach((el, i) => {
        el.style.animation = "none";
        el.style.opacity = "0";
        el.style.transform = `translateY(${cssNum("--intro-cascade-from-y", -10)}px)`;
        el.style.filter = `blur(${cssNum("--intro-cascade-from-blur", 2)}px)`;

        void el.offsetWidth;

        const delay = i * stagger;
        el.style.animation = `introCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

        el.addEventListener("animationend", () => {
          el.style.filter = "blur(0)";
        }, { once: true });
      });

      return true;
    };

    const runIntroCascadeWhenReady = () => {
      if (runIntroCascade()) return;

      const obs = new MutationObserver(() => {
        if (runIntroCascade()) obs.disconnect();
      });

      obs.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => obs.disconnect(), 2000);
    };

    const triggerCascadeAfterBack = () => {
      if (animateStudyListCascade()) return;

      const obs = new MutationObserver(() => {
        if (animateStudyListCascade()) obs.disconnect();
      });

      obs.observe(document.body, { childList: true, subtree: true });
      setTimeout(() => obs.disconnect(), 1200);
    };

    document.addEventListener("click", (e) => {
      const target = e.target;
      if (!target || !target.closest) return;

      const studyEl = target.closest("[data-study]");
      if (studyEl && isStudyTrigger(studyEl)) {
        const link = studyEl.closest("a[href]");
        if (link) {
          e.preventDefault();
          const href = link.getAttribute("href");

          // blur background + fade brandyura on click
          blurBG();
          fadeLogo();

          merge();

          const ms = cssMs("--plus-ms", 520);
          setTimeout(() => { window.location.href = href; }, Math.max(0, ms + 40));
        } else {
          blurBG();
          fadeLogo();
          merge();
        }
        return;
      }

      const backEl = target.closest("button, a");
      if (backEl && isBackTrigger(backEl)) {
        unmerge();
        unblurBG();
        unfadeLogo();
        triggerCascadeAfterBack();
      }
    }, { capture: true });

    // ensure blur/fade doesn't persist on bfcache restore / page show
    window.addEventListener("pageshow", () => {
      unblurBG();
      unfadeLogo();
    }, { passive: true });

    window.addEventListener("resize", () => {
      updateConnectorWidth();
      setConnectorMetrics();
    }, { passive: true });

    requestAnimationFrame(() => {
      requestAnimationFrame(() => {
        document.body.classList.remove("is-intro");
        window.runGalleryIntroCascadeOnce?.();
        updateConnectorWidth();
        setConnectorMetrics();

        requestAnimationFrame(() => {
          runIntroCascadeWhenReady();
        });
      });
    })();
  </script>
