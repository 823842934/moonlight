---
const {
  title = "brandyura",
  description = "brandyura",
  ogImage = "/og.png",
} = Astro.props;

const siteUrl = "https://brandyura.com";
const canonical = new URL(Astro.url.pathname, siteUrl).toString();
const ogImageAbs = new URL(ogImage, siteUrl).toString();
---
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{title}</title>

  <link rel="canonical" href={canonical} />
  <meta name="description" content={description} />

  <meta property="og:site_name" content="brandyura" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content={title} />
  <meta property="og:description" content={description} />
  <meta property="og:url" content={canonical} />

  <meta property="og:image" content={ogImageAbs} />
  <meta property="og:image:width" content="960" />
  <meta property="og:image:height" content="960" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:alt" content="brandyura preview" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content={title} />
  <meta name="twitter:description" content={description} />
  <meta name="twitter:image" content={ogImageAbs} />

  <link rel="icon" href="/favicon.ico" />
  <link rel="preload" href="/fonts/ABCDiatype-Regular.woff" as="font" type="font/woff" crossorigin />
  <link rel="preload" href="/fonts/ABCDiatype-Bold.woff" as="font" type="font/woff" crossorigin />

  <style>
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --corner-inset: 22px;
      --corner-size: 28px;

      --intro-ms: 800ms;
      --intro-ease: cubic-bezier(.2,.9,.2,1);
      --intro-blur: 18px;
      --intro-scale: 0.985;

      /* normal top-to-bottom cascade */
      --cascade-ms: 420ms;
      --cascade-stagger: 80ms;

      --cascade-from-opacity: 0.25;
      --cascade-from-y: -10px;
      --cascade-from-blur: 1px;

      /* merge animation */
      --merge-ms: 520ms;
      --merge-ease: cubic-bezier(.2,.9,.2,1);
      --merge-scale: 1.65;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      max-width: 100%;
      overflow-x: hidden;
    }

    body {
      font-family: "ABC Diatype", system-ui, sans-serif;
      color: #000000;
      overflow-x: clip;
    }

    /* Intro */
    .page-intro-wrap {
      min-height: 100%;
      transition:
        filter var(--intro-ms) var(--intro-ease),
        transform var(--intro-ms) var(--intro-ease);
      will-change: filter, transform;
    }

    .intro-wash {
      position: fixed;
      inset: 0;
      background: #ffffff;
      z-index: 9000;
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--intro-ms) var(--intro-ease);
      will-change: opacity;
    }

    body.is-intro { overflow: hidden; }

    body.is-intro .page-intro-wrap {
      filter: blur(var(--intro-blur));
      transform: scale(var(--intro-scale));
      transform-origin: center;
    }

    body.is-intro .intro-wash { opacity: 1; }

    /* Corner plus marks */
    .corner-plus {
      position: fixed;
      z-index: 9999;
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-weight: 700;
      font-size: var(--corner-size);
      line-height: 1;
      color: #000;
      user-select: none;
      pointer-events: none;
      transform-origin: center;
      will-change: transform, opacity;
    }

    .corner-plus.tl { top: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.tr { top: var(--corner-inset); right: var(--corner-inset); }
    .corner-plus.bl { bottom: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.br { bottom: var(--corner-inset); right: var(--corner-inset); }

    /* ✅ Normal cascade (faded -> full) */
    @keyframes studyCascadeIn {
      from {
        opacity: var(--cascade-from-opacity);
        transform: translateY(var(--cascade-from-y));
        filter: blur(var(--cascade-from-blur));
      }
      to {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      :root {
        --intro-ms: 0ms;
        --cascade-ms: 0ms;
        --cascade-stagger: 0ms;
        --merge-ms: 0ms;
      }
      .intro-wash { display: none; }
    }
  </style>
</head>

<body class="is-intro">
  <div class="corner-plus tl">＋</div>
  <div class="corner-plus tr">＋</div>
  <div class="corner-plus bl">＋</div>
  <div class="corner-plus br">＋</div>

  <div class="intro-wash" aria-hidden="true"></div>

  <div class="page-intro-wrap">
    <slot />
  </div>

  <script is:inline>
    (() => {
      const state = { mode: "rest", anims: [] };

      const prefersReduced = () =>
        window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

      const $ = (sel) => document.querySelector(sel);

      const getPluses = () => ({
        tl: $(".corner-plus.tl"),
        tr: $(".corner-plus.tr"),
        bl: $(".corner-plus.bl"),
        br: $(".corner-plus.br"),
      });

      const isStudyTrigger = (el) => {
        const v = el.getAttribute("data-study") || "";
        let val = v;
        try { val = decodeURIComponent(val); } catch {}
        val = val.trim().toLowerCase();
        return val.startsWith("study:") && val.includes("[//");
      };

      const isBackTrigger = (el) => {
        const txt = (el.textContent || "").trim().toLowerCase();
        return txt === "<- back" || txt === "← back" || txt === "back";
      };

      const cssMs = (name, fallback) => {
        const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        if (!raw) return fallback;
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      const cssNum = (name, fallback) => {
        const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        if (!raw) return fallback;
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      const cssStr = (name, fallback) => {
        const raw = getComputedStyle(document.documentElement).getPropertyValue(name).trim();
        return raw || fallback;
      };

      const cancelAll = () => {
        for (const a of state.anims) {
          try { a.cancel(); } catch {}
        }
        state.anims = [];
      };

      const clearInline = () => {
        const { tl, tr, bl, br } = getPluses();
        for (const el of [tl, tr, bl, br]) {
          if (!el) continue;
          el.style.transform = "";
          el.style.opacity = "";
        }
      };

      const setInstantMerged = () => {
        const { tl, tr, bl, br } = getPluses();
        if (!tl || !tr || !bl || !br) return;

        const rTL = tl.getBoundingClientRect();
        const rTR = tr.getBoundingClientRect();
        const rBL = bl.getBoundingClientRect();
        const rBR = br.getBoundingClientRect();

        const dxTR = (rTL.left + rTL.width/2) - (rTR.left + rTR.width/2);
        const dyTR = (rTL.top  + rTL.height/2) - (rTR.top  + rTR.height/2);
        const dxBR = (rBL.left + rBL.width/2) - (rBR.left + rBR.width/2);
        const dyBR = (rBL.top  + rBL.height/2) - (rBR.top  + rBR.height/2);

        const s = cssNum("--merge-scale", 1.65);

        tr.style.transform = `translate(${dxTR}px, ${dyTR}px) rotate(360deg) scale(${s})`;
        tr.style.opacity = "0";

        br.style.transform = `translate(${dxBR}px, ${dyBR}px) rotate(360deg) scale(${s})`;
        br.style.opacity = "0";

        tl.style.transform = `rotate(360deg) scale(${s})`;
        bl.style.transform = `rotate(360deg) scale(${s})`;
      };

      const mergePluses = () => {
        if (state.mode === "merged") return;
        const { tl, tr, bl, br } = getPluses();
        if (!tl || !tr || !bl || !br) return;

        cancelAll();

        if (prefersReduced()) {
          setInstantMerged();
          state.mode = "merged";
          return;
        }

        const ms = cssMs("--merge-ms", 520);
        const easing = cssStr("--merge-ease", "cubic-bezier(.2,.9,.2,1)");
        const s = cssNum("--merge-scale", 1.65);

        const rTL = tl.getBoundingClientRect();
        const rTR = tr.getBoundingClientRect();
        const rBL = bl.getBoundingClientRect();
        const rBR = br.getBoundingClientRect();

        const dxTR = (rTL.left + rTL.width/2) - (rTR.left + rTR.width/2);
        const dyTR = (rTL.top  + rTL.height/2) - (rTR.top  + rTR.height/2);
        const dxBR = (rBL.left + rBL.width/2) - (rBR.left + rBR.width/2);
        const dyBR = (rBL.top  + rBL.height/2) - (rBR.top  + rBR.height/2);

        const fly = (el, dx, dy) => el.animate(
          [
            { transform: "translate(0px, 0px) rotate(0deg) scale(1)", opacity: 1 },
            { transform: `translate(${dx}px, ${dy}px) rotate(360deg) scale(${s})`, opacity: 0 }
          ],
          { duration: ms, easing, fill: "forwards" }
        );

        const pop = (el) => el.animate(
          [
            { transform: "rotate(0deg) scale(1)" },
            { transform: `rotate(360deg) scale(${s})` }
          ],
          { duration: ms, easing, fill: "forwards" }
        );

        state.anims = [
          fly(tr, dxTR, dyTR),
          fly(br, dxBR, dyBR),
          pop(tl),
          pop(bl),
        ];

        state.mode = "merged";
      };

      const unmergePluses = () => {
        if (state.mode === "rest") return;

        if (prefersReduced()) {
          clearInline();
          state.mode = "rest";
          return;
        }

        if (state.anims.length) {
          for (const a of state.anims) {
            try { a.reverse(); } catch {}
          }
          Promise.allSettled(state.anims.map(a => a.finished)).then(() => {
            cancelAll();
            clearInline();
          });
        } else {
          clearInline();
        }

        state.mode = "rest";
      };

      const animateStudyListCascade = () => {
        const items = Array.from(document.querySelectorAll("[data-study]"))
          .filter((el) => el instanceof HTMLElement && isStudyTrigger(el));

        if (!items.length) return false;

        const stagger = cssNum("--cascade-stagger", 80);
        const ms = cssNum("--cascade-ms", 420);

        items.forEach((el, i) => {
          el.style.animation = "none";
          el.style.opacity = String(cssNum("--cascade-from-opacity", 0.25));
          el.style.transform = `translateY(${cssNum("--cascade-from-y", -10)}px)`;
          el.style.filter = `blur(${cssNum("--cascade-from-blur", 1)}px)`;

          void el.offsetWidth;

          const delay = i * stagger;
          el.style.animation = `studyCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

          el.addEventListener("animationend", () => {
            el.style.filter = "blur(0)";
          }, { once: true });
        });

        return true;
      };

      const triggerCascadeAfterBack = () => {
        if (animateStudyListCascade()) return;

        const obs = new MutationObserver(() => {
          if (animateStudyListCascade()) obs.disconnect();
        });

        obs.observe(document.body, { childList: true, subtree: true });
        setTimeout(() => obs.disconnect(), 1200);
      };

      document.addEventListener("click", (e) => {
  const target = e.target;
  if (!target || !target.closest) return;

  const studyEl = target.closest("[data-study]");
  if (studyEl && isStudyTrigger(studyEl)) {
    const link = studyEl.closest("a[href]");
    const ms = cssMs("--merge-ms", 520);

    if (link) {
      // delay navigation so animation can be seen
      e.preventDefault();
      mergePluses();
      window.setTimeout(() => {
        window.location.href = link.href;
      }, ms);
    } else {
      mergePluses();
    }
    return;
  }

  const backEl = target.closest("button, a");
  if (backEl && isBackTrigger(backEl)) {
    const ms = cssMs("--merge-ms", 520);

    // delay back so reverse can be seen
    e.preventDefault();
    unmergePluses();
    triggerCascadeAfterBack();

    window.setTimeout(() => {
      if (backEl.tagName === "A" && backEl.getAttribute("href")) {
        window.location.href = backEl.getAttribute("href");
      } else {
        history.back();
      }
    }, ms);

    return;
  }
}, { capture: true });

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          document.body.classList.remove("is-intro");
        });
      });
    })();
  </script>
</body>
</html>
