---
const {
  title = "Brandyura",
  description = "Brandyura",
  ogImage = "/og.png",
} = Astro.props;

const siteUrl = "https://brandyura.com";
const canonical = new URL(Astro.url.pathname, siteUrl).toString();
const ogImageAbs = new URL(ogImage, siteUrl).toString();
---

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{title}</title>


  <link rel="canonical" href={canonical} />
  <meta name="description" content={description} />

  <meta property="og:site_name" content="brandyura" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content={title} />
  <meta property="og:description" content={description} />
  <meta property="og:url" content={canonical} />

  <meta property="og:image" content={ogImageAbs} />
  <meta property="og:image:width" content="960" />
  <meta property="og:image:height" content="960" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:alt" content="brandyura preview" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content={title} />
  <meta name="twitter:description" content={description} />
  <meta name="twitter:image" content={ogImageAbs} />

  <link rel="icon" href="/favicon.ico" />
  <link rel="preload" href="/fonts/ABCDiatype-Regular.woff" as="font" type="font/woff" crossorigin />
  <link rel="preload" href="/fonts/ABCDiatype-Bold.woff" as="font" type="font/woff" crossorigin />

  <style>
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --corner-inset: 22px;
      --corner-size: 28px;

      --cascade-ms: 420ms;
      --cascade-stagger: 80ms;
      --cascade-from-opacity: 0.25;
      --cascade-from-y: -10px;
      --cascade-from-blur: 1px;

      --intro-cascade-ms: 520ms;
      --intro-cascade-stagger: 90ms;
      --intro-cascade-from-opacity: 0;
      --intro-cascade-from-y: -10px;
      --intro-cascade-from-blur: 2px;

      --plus-ms: 520ms;
      --plus-ease: cubic-bezier(.22,.61,.36,1);
      --left-scale: 2.1;
      --right-scale: 0.45;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      max-width: 100%;
      overflow: hidden !important;
      /* Hide scrollbar for Chrome, Safari and Opera */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* IE and Edge */
    }

    html::-webkit-scrollbar,
    body::-webkit-scrollbar {
      display: none;
      width: 0 !important;
      height: 0 !important;
    }

    /* Hide scrollbars globally for all elements */
    * {
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* IE and Edge */
    }

    *::-webkit-scrollbar {
      display: none;
      width: 0 !important;
      height: 0 !important;
    }

    body {
      font-family: "ABC Diatype", system-ui, sans-serif;
      color: #000000;
      overflow-x: clip;
    }

    /* White preload screen - shows FIRST before anything */
    .preload-screen {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
      background: #ffffff !important;
      z-index: 100000 !important; /* Above splash */
      pointer-events: none;
    }

    .preload-screen.hidden {
      display: none !important;
    }

    /* Splash intro overlay */
    .splash-overlay {
      position: fixed !important;
      top: 0 !important;
      left: 0 !important;
      right: 0 !important;
      bottom: 0 !important;
      width: 100% !important;
      height: 100% !important;
      margin: 0 !important;
      padding: 0 !important;
      background: #ffffff !important;
      z-index: 99999 !important;
      display: flex !important;
      align-items: center !important;
      justify-content: center !important;
      transition: opacity 0.5s ease-out;
    }

    .splash-overlay.fade-out {
      opacity: 0;
      pointer-events: none;
    }

    .splash-overlay.hidden {
      display: none !important;
    }

    .splash-image {
      max-width: 80%;
      max-height: 80%;
      width: auto;
      height: auto;
      object-fit: contain;
      margin: 0 auto;
      opacity: 0; /* Hidden initially until preload ends */
    }

    .splash-image.visible {
      opacity: 1;
    }

    body.video-playing,
    body.video-playing * {
      cursor: default !important;
      pointer-events: none !important;
    }
    
    body.video-playing video {
      pointer-events: auto !important;
    }

    /* background image */
    .bg-image {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 0;
      pointer-events: none;
      object-fit: contain;
      object-position: center center;
      will-change: opacity;
      isolation: isolate;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      contain: layout style paint;
      opacity: 1;
    }

    .bg-image.hidden {
      opacity: 0;
      visibility: hidden;
    }

    /* background video (for transitions) */
    .bg-video {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
      object-fit: contain;
      object-position: center center;
      will-change: opacity;
      isolation: isolate;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      contain: layout style paint;
      opacity: 0;
      visibility: hidden;
    }

    .bg-video.visible {
      opacity: 1;
      visibility: visible;
    }

    @keyframes imageBlurIn {
      from {
        filter: blur(20px);
        opacity: 0;
      }
      to {
        filter: blur(0);
        opacity: 1;
      }
    }

    /* Tall screens (phones) */
    @media (max-width: 640px) {
      .bg-image,
      .bg-video {
        object-fit: cover;
        object-position: center center;
      }
    }

    /* Ultra-wide or landscape tablets/desktops */
    @media (min-aspect-ratio: 19/10) {
      .bg-image,
      .bg-video {
        object-fit: cover;
        object-position: center center;
      }
    }

    /* Landscape mobile */
    @media (max-width: 932px) and (orientation: landscape) {
      .bg-image,
      .bg-video {
        object-fit: cover;
      }
    }

    .page-intro-wrap {
      position: relative;
      z-index: 1;
      min-height: 100%;
    }

    .corner-plus {
      position: fixed;
      z-index: 9999;
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-weight: 700;
      font-size: var(--corner-size);
      line-height: 1;
      color: #000;
      user-select: none;
      pointer-events: none;
      transform-origin: center;
      transition:
        transform var(--plus-ms) var(--plus-ease),
        opacity var(--plus-ms) var(--plus-ease);
      will-change: transform, opacity;
    }

    .corner-plus.tl { top: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.tr { top: var(--corner-inset); right: var(--corner-inset); }
    .corner-plus.bl { bottom: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.br { bottom: var(--corner-inset); right: var(--corner-inset); }

    body.plus-merged .corner-plus.tl,
    body.plus-merged .corner-plus.bl {
      transform: translateX(calc(50vw - var(--corner-inset) - var(--corner-size)/2)) scale(var(--left-scale));
      opacity: 0;
    }
    body.plus-merged .corner-plus.tr,
    body.plus-merged .corner-plus.br {
      transform: translateX(calc(-50vw + var(--corner-inset) + var(--corner-size)/2)) scale(var(--right-scale));
      opacity: 0;
    }

    @keyframes studyCascadeIn {
      from {
        opacity: var(--cascade-from-opacity, 0.25);
        transform: translateY(var(--cascade-from-y, -10px));
        filter: blur(var(--cascade-from-blur, 1px));
      }
      to {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    @keyframes introCascadeIn {
      from {
        opacity: var(--intro-cascade-from-opacity, 0);
        transform: translateY(var(--intro-cascade-from-y, -10px));
        filter: blur(var(--intro-cascade-from-blur, 2px));
      }
      to {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }
  </style>
</head>

<body>
  <!-- White preload screen (shows FIRST for 1.3s) -->
  <div class="preload-screen" id="preload-screen"></div>

  <!-- Splash intro image (shows after preload, fades to white) -->
  <div class="splash-overlay" id="splash-overlay">
    <img 
      class="splash-image" 
      id="splash-image"
      src="/brandyura-intro-logo.png" 
      alt=""
      aria-hidden="true"
    />
  </div>

  <!-- Intro video (plays after splash screen) -->
  <video
    class="bg-video visible"
    id="bg-video-intro"
    muted
    playsinline
    webkit-playsinline
    preload="auto"
    aria-hidden="true"
    tabindex="-1"
  >
    <source src="/0000-0051.mp4" type="video/mp4" />
  </video>

  <!-- Background image (hidden until intro video ends) -->
  <img
    class="bg-image hidden"
    id="bg-image"
    src="/bradnyura-tile-rendertest1.png"
    alt=""
    aria-hidden="true"
  />

  <!-- Background video (hidden by default) -->
  <video
    class="bg-video"
    id="bg-video"
    muted
    playsinline
    webkit-playsinline
    preload="auto"
    aria-hidden="true"
    tabindex="-1"
  >
    <source src="/0071-0096.mp4" type="video/mp4" />
  </video>

  <!-- Background video for back transition -->
  <video
    class="bg-video"
    id="bg-video-back"
    muted
    playsinline
    webkit-playsinline
    preload="auto"
    aria-hidden="true"
    tabindex="-1"
  >
    <source src="/0070-0096rev.mp4" type="video/mp4" />
  </video>

  <div class="corner-plus tl">＋</div>
  <div class="corner-plus tr">＋</div>
  <div class="corner-plus bl">＋</div>
  <div class="corner-plus br">＋</div>

  <div class="page-intro-wrap">
    <slot />
  </div>

  <script is:inline>
    (() => {
      const root = document.documentElement;

      // Preload screen logic (white screen for 1.3s before anything)
      const preloadScreen = document.getElementById('preload-screen');
      const splashImage = document.getElementById('splash-image');

      // Splash screen logic
      const splashOverlay = document.getElementById('splash-overlay');
      const bgVideoIntro = document.getElementById('bg-video-intro');
      
      // After 1.5s, hide preload and show the splash image instantly
      if (preloadScreen && splashImage) {
        setTimeout(() => {
          // Hide the white preload screen instantly
          preloadScreen.classList.add('hidden');
          
          // Show the splash image instantly
          splashImage.classList.add('visible');
        }, 500); // 0.5 second white screen
      }
      
      // Preload the intro video during splash screen
      if (bgVideoIntro) {
        bgVideoIntro.load();
      }
      
      if (splashOverlay) {
        // Show splash for 3 seconds AFTER preload ends, then fade to white
        setTimeout(() => {
          splashOverlay.classList.add('fade-out');
          
          // Function to play video when ready
          const playWhenReady = () => {
            if (bgVideoIntro) {
              // Check if video can play
              if (bgVideoIntro.readyState >= 3) { // HAVE_FUTURE_DATA or better
                bgVideoIntro.play().catch(() => {});
              } else {
                // Wait for video to be ready
                const onCanPlay = () => {
                  bgVideoIntro.removeEventListener('canplaythrough', onCanPlay);
                  bgVideoIntro.play().catch(() => {});
                };
                bgVideoIntro.addEventListener('canplaythrough', onCanPlay);
                
                // Fallback: try to play anyway after 500ms
                setTimeout(() => {
                  bgVideoIntro.removeEventListener('canplaythrough', onCanPlay);
                  bgVideoIntro.play().catch(() => {});
                }, 500);
              }
            }
          };
          
          // Start video partway through fade so first frame is ready
          setTimeout(playWhenReady, 250); // Start video 250ms into the 500ms fade
          
          // After fade completes, hide splash
          setTimeout(() => {
            splashOverlay.classList.add('hidden');
          }, 500); // matches transition duration
        }, 3500); // 0.5s preload + 3s splash display
      }

      // Video transition elements
      const bgImage = document.getElementById('bg-image');
      const bgVideo = document.getElementById('bg-video');
      const bgVideoBack = document.getElementById('bg-video-back');
      // bgVideoIntro already declared above for splash logic

      // Lock to prevent clicks during video playback
      let isVideoPlaying = true; // Start locked during splash

      // Set body class for cursor
      document.body.classList.add('video-playing');

      // Handle tab visibility change - pause/resume video
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          // User left - pause any playing video
          if (bgVideoIntro && !bgVideoIntro.paused) bgVideoIntro.pause();
          if (bgVideo && !bgVideo.paused) bgVideo.pause();
          if (bgVideoBack && !bgVideoBack.paused) bgVideoBack.pause();
        } else if (document.visibilityState === 'visible' && isVideoPlaying) {
          // User returned and video was playing - try to resume
          let activeVideo = null;
          
          if (bgVideoIntro && bgVideoIntro.classList.contains('visible')) {
            activeVideo = bgVideoIntro;
          } else if (bgVideo && bgVideo.classList.contains('visible')) {
            activeVideo = bgVideo;
          } else if (bgVideoBack && bgVideoBack.classList.contains('visible')) {
            activeVideo = bgVideoBack;
          }
          
          if (activeVideo) {
            const startTime = activeVideo.currentTime;
            
            // Force muted
            activeVideo.muted = true;
            
            // Nudge time to wake up decoder
            activeVideo.currentTime = startTime + 0.001;
            
            // Try to play
            activeVideo.play().catch(() => {});
            
            // Check if video is actually progressing after 300ms
            setTimeout(() => {
              const hasProgressed = activeVideo.currentTime > startTime + 0.01;
              
              if (!hasProgressed) {
                // Video is stuck - try reload from current position
                const stuckTime = activeVideo.currentTime;
                
                activeVideo.load();
                
                // Wait for video to be ready after load
                const onCanPlay = () => {
                  activeVideo.removeEventListener('canplay', onCanPlay);
                  activeVideo.currentTime = stuckTime;
                  activeVideo.muted = true;
                  activeVideo.play().catch(() => {});
                  
                  // Check again if it's progressing after reload
                  const timeAfterReload = activeVideo.currentTime;
                  setTimeout(() => {
                    const progressedAfterReload = activeVideo.currentTime > timeAfterReload + 0.01;
                    
                    if (!progressedAfterReload) {
                      // Still stuck - skip to end state
                      if (bgVideoIntro) {
                        bgVideoIntro.classList.remove('visible');
                        bgVideoIntro.pause();
                      }
                      if (bgVideo) {
                        bgVideo.classList.remove('visible');
                        bgVideo.style.visibility = '';
                        bgVideo.style.opacity = '';
                        bgVideo.pause();
                      }
                      if (bgVideoBack) {
                        bgVideoBack.classList.remove('visible');
                        bgVideoBack.style.visibility = '';
                        bgVideoBack.style.opacity = '';
                        bgVideoBack.pause();
                      }
                      if (splashOverlay) {
                        splashOverlay.classList.add('hidden');
                      }
                      if (bgImage) {
                        bgImage.classList.remove('hidden');
                        bgImage.style.visibility = '';
                        bgImage.style.opacity = '';
                      }
                      isVideoPlaying = false;
                      document.body.classList.remove('video-playing');
                    }
                  }, 300);
                };
                
                activeVideo.addEventListener('canplay', onCanPlay);
                
                // Fallback if canplay never fires
                setTimeout(() => {
                  activeVideo.removeEventListener('canplay', onCanPlay);
                }, 2000);
              }
            }, 300);
          }
        }
      });

      // Handle intro video ending
      if (bgVideoIntro) {
        bgVideoIntro.addEventListener('ended', () => {
          bgVideoIntro.classList.remove('visible');
          bgImage.classList.remove('hidden');
          bgImage.classList.add('fade-in');
          isVideoPlaying = false;
          document.body.classList.remove('video-playing');
        });
      }

      // Trigger items that should play the video
      const videoTriggerItems = ['studies', 'biography', 'statement', 'process', 'social', 'info'];

      // Check if a clicked item should trigger video
      const shouldTriggerVideo = (itemName) => {
        return videoTriggerItems.includes(itemName.toLowerCase());
      };

      // Play video transition: wait for video ready, then hide image -> play video -> on end, show image
      const playVideoTransition = () => {
        if (!bgImage || !bgVideo || isVideoPlaying) return;

        isVideoPlaying = true;
        document.body.classList.add('video-playing');

        // Prepare video element
        bgVideo.currentTime = 0;
        bgVideo.style.visibility = 'visible';
        bgVideo.style.opacity = '1';
        bgVideo.classList.add('visible');

        // Hide image and play - using play() promise to ensure video is ready
        const playPromise = bgVideo.play();
        
        if (playPromise !== undefined) {
          playPromise.then(() => {
            // Video is playing, safe to hide image
            bgImage.style.visibility = 'hidden';
            bgImage.style.opacity = '0';
            bgImage.classList.add('hidden');
          }).catch(() => {
            // Autoplay failed, hide image anyway and try to continue
            bgImage.style.visibility = 'hidden';
            bgImage.style.opacity = '0';
            bgImage.classList.add('hidden');
          });
        } else {
          // Fallback for older browsers
          bgImage.style.visibility = 'hidden';
          bgImage.style.opacity = '0';
          bgImage.classList.add('hidden');
        }

        // When video ends, swap back to image
        const onEnded = () => {
          bgVideo.classList.remove('visible');
          bgVideo.style.visibility = '';
          bgVideo.style.opacity = '';
          bgImage.classList.remove('hidden');
          bgImage.style.visibility = '';
          bgImage.style.opacity = '';
          bgVideo.removeEventListener('ended', onEnded);
          isVideoPlaying = false;
          document.body.classList.remove('video-playing');
        };
        bgVideo.addEventListener('ended', onEnded);
      };

      // Play back video transition (L2 -> L1)
      const playBackVideoTransition = () => {
        if (!bgImage || !bgVideoBack || isVideoPlaying) return;

        isVideoPlaying = true;
        document.body.classList.add('video-playing');

        // Prepare video element
        bgVideoBack.currentTime = 0;
        bgVideoBack.style.visibility = 'visible';
        bgVideoBack.style.opacity = '1';
        bgVideoBack.classList.add('visible');

        // Hide image and play - using play() promise to ensure video is ready
        const playPromise = bgVideoBack.play();
        
        if (playPromise !== undefined) {
          playPromise.then(() => {
            // Video is playing, safe to hide image
            bgImage.style.visibility = 'hidden';
            bgImage.style.opacity = '0';
            bgImage.classList.add('hidden');
          }).catch(() => {
            // Autoplay failed, hide image anyway and try to continue
            bgImage.style.visibility = 'hidden';
            bgImage.style.opacity = '0';
            bgImage.classList.add('hidden');
          });
        } else {
          // Fallback for older browsers
          bgImage.style.visibility = 'hidden';
          bgImage.style.opacity = '0';
          bgImage.classList.add('hidden');
        }

        // When video ends, swap back to image
        const onEnded = () => {
          bgVideoBack.classList.remove('visible');
          bgVideoBack.style.visibility = '';
          bgVideoBack.style.opacity = '';
          bgImage.classList.remove('hidden');
          bgImage.style.visibility = '';
          bgImage.style.opacity = '';
          bgVideoBack.removeEventListener('ended', onEnded);
          isVideoPlaying = false;
          document.body.classList.remove('video-playing');
        };
        bgVideoBack.addEventListener('ended', onEnded);
      };

      // Expose functions globally so index.astro can call them
      window.playBackgroundVideo = playVideoTransition;
      window.playBackgroundVideoBack = playBackVideoTransition;
      window.isBackgroundVideoPlaying = () => isVideoPlaying;

      // study triggers (existing)
      const isStudyTrigger = (el) => {
        const v = el.getAttribute("data-study") || "";
        let val = v;
        try { val = decodeURIComponent(val); } catch {}
        val = val.trim().toLowerCase();
        return val.startsWith("study:") && val.includes("[//");
      };

      // NEW: node triggers (biography/statement/process/hello/social/placeholder)
      const isNodeTrigger = (el) => el && el.hasAttribute && el.hasAttribute("data-node");

      const isBackTrigger = (el) => {
        const txt = (el.textContent || "").trim().toLowerCase();
        return txt === "<- back" || txt === "← back" || txt === "back" || txt === "⟵ back";
      };

      const cssNum = (name, fallback) => {
        const raw = getComputedStyle(root).getPropertyValue(name).trim();
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      const cssMs = (name, fallback) => {
        const raw = getComputedStyle(root).getPropertyValue(name).trim();
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      // Track navigation depth
      // 0 = gallery, 1 = study/node view (2nd level), 2+ = deeper levels
      let currentDepth = 0;

      // plus merge animation
      const merge = () => {
        // Only trigger animation if going from gallery (depth 0) to 2nd level (depth 1)
        if (currentDepth === 0) {
          // allow retrigger if user clicks different items quickly
          document.body.classList.remove("plus-merged");
          void document.body.offsetWidth;

          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              document.body.classList.add("plus-merged");
            });
          });
          
          currentDepth = 1;
        }
        // If already at depth 1 or deeper, don't re-trigger animation
      };

      const unmerge = () => {
        // Only unmerge when going back to gallery (depth 0)
        if (currentDepth === 1) {
          document.body.classList.remove("plus-merged");
          currentDepth = 0;
        }
      };

      const animateStudyListCascade = () => {
        const items = Array.from(document.querySelectorAll("[data-study]"))
          .filter((el) => el instanceof HTMLElement && isStudyTrigger(el));

        if (!items.length) return false;

        const stagger = cssNum("--cascade-stagger", 80);
        const ms = cssNum("--cascade-ms", 420);

        items.forEach((el, i) => {
          el.style.animation = "none";
          el.style.opacity = String(cssNum("--cascade-from-opacity", 0.25));
          el.style.transform = `translateY(${cssNum("--cascade-from-y", -10)}px)`;
          el.style.filter = `blur(${cssNum("--cascade-from-blur", 1)}px)`;

          void el.offsetWidth;

          const delay = i * stagger;
          el.style.animation = `studyCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

          el.addEventListener("animationend", () => {
            el.style.filter = "blur(0)";
          }, { once: true });
        });

        return true;
      };

      let didIntroCascade = false;

      const runIntroCascade = () => {
        if (didIntroCascade) return false;

        const items = Array.from(document.querySelectorAll("[data-intro-cascade]"))
          .filter((el) => el instanceof HTMLElement);

        if (!items.length) return false;

        didIntroCascade = true;

        const stagger = cssNum("--intro-cascade-stagger", 90);
        const ms = cssNum("--intro-cascade-ms", 520);

        items.forEach((el, i) => {
          el.style.animation = "none";
          el.style.opacity = "0";
          el.style.transform = `translateY(${cssNum("--intro-cascade-from-y", -10)}px)`;
          el.style.filter = `blur(${cssNum("--intro-cascade-from-blur", 2)}px)`;

          void el.offsetWidth;

          const delay = i * stagger;
          el.style.animation = `introCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

          el.addEventListener("animationend", () => {
            el.style.filter = "blur(0)";
          }, { once: true });
        });

        return true;
      };

      const runIntroCascadeWhenReady = () => {
        if (runIntroCascade()) return;

        const obs = new MutationObserver(() => {
          if (runIntroCascade()) obs.disconnect();
        });

        obs.observe(document.body, { childList: true, subtree: true });
        setTimeout(() => obs.disconnect(), 2000);
      };

      const triggerCascadeAfterBack = () => {
        if (animateStudyListCascade()) return;

        const obs = new MutationObserver(() => {
          if (animateStudyListCascade()) obs.disconnect();
        });

        obs.observe(document.body, { childList: true, subtree: true });
        setTimeout(() => obs.disconnect(), 1200);
      };

      document.addEventListener("click", (e) => {
        const target = e.target;
        if (!target || !target.closest) return;

        // Block all clicks while video is playing (but allow the initial click through)
        if (isVideoPlaying) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        // Trigger videos IMMEDIATELY on click
        // Check for folder item clicks that should trigger video (L1 -> L2)
        const folderItem = target.closest(".folder-item.folder");
        if (folderItem) {
          const itemName = folderItem.dataset.name || folderItem.textContent || "";
          if (shouldTriggerVideo(itemName.trim())) {
            playVideoTransition();
            // Don't block - let the click continue to index.astro
          }
        }

        // Check for back button click from L2 to L1 ONLY
        const backItem = target.closest(".folder-item.back");
        if (backItem) {
          const parentHeader = document.querySelector('.folder-header');
          if (parentHeader && parentHeader.textContent) {
            const headerText = parentHeader.textContent.replace('└── ', '').trim().toLowerCase();
            const l2Items = ['studies', 'biography', 'statement', 'process', 'social', 'info'];
            if (l2Items.includes(headerText)) {
              playBackVideoTransition();
              // Don't block - let the click continue to index.astro
            }
          }
        }

        // Check if animation is in progress
        if (document.body.hasAttribute('data-is-animating')) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        const studyEl = target.closest("[data-study]");
        if (studyEl && isStudyTrigger(studyEl)) {
          const link = studyEl.closest("a[href]");
          if (link) {
            e.preventDefault();
            const href = link.getAttribute("href");

            merge();

            const ms = cssMs("--plus-ms", 520);
            setTimeout(() => { window.location.href = href; }, Math.max(0, ms + 40));
          } else {
            merge();
          }
          return;
        }

        // NEW: apply same plus animation for any [data-node] click
        const nodeEl = target.closest("[data-node]");
        if (nodeEl && isNodeTrigger(nodeEl)) {
          merge();
          return;
        }

        const backEl = target.closest("button, a");
        if (backEl && isBackTrigger(backEl)) {
          unmerge();
          triggerCascadeAfterBack();
        }
      }, { capture: true });

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          window.runGalleryIntroCascadeOnce?.();

          requestAnimationFrame(() => {
            runIntroCascadeWhenReady();
          });
        });
      });

    })();
  </script>
</body>
</html>