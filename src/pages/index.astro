---
import FrameLayout from "../layouts/FrameLayout.astro";
---

<FrameLayout title="Body of Work">
  <section class="hero">
    <div class="stack">
      <h1 id="logo"><span class="logo-char">/ /</span>&nbsp;brandyura</h1>
      <nav id="folder-nav"></nav>
    </div>
  </section>

  <script>
    // Logo animation
    const logoChar = document.querySelector('.logo-char') as HTMLElement;
    if (logoChar) {
      const symbols = ['/ /', '- -', '\\ \\', '| |'];
      let index = 0;
      setInterval(() => {
        index = (index + 1) % symbols.length;
        logoChar.textContent = symbols[index];
      }, 150);
    }

    interface Study {
      id: string;
      children: string[];
    }

    interface NavState {
      path: string[];
      direction: "in" | "out" | null;
    }

    const studies: Study[] = [
      { id: "000-0001", children: ["About", "Purpose", "Date"] },
    ];

    const l1Sections: Record<string, string[]> = {
      "Gallery": ["Studies"],
      "About": ["Biography", "Statement", "Process"],
      "Contact": ["Social"],
      "Legal": ["Info"],
    };

    function buildStructure(): Record<string, string[]> {
      const struct: Record<string, string[]> = {
        // L2 - Top level section children
        "root/Gallery": ["Studies"],
        "root/About": ["Biography", "Statement", "Process"],
        "root/Contact": ["Social"],
        "root/Legal": ["Info"],
        
        // L3 - Gallery's children (Studies folder contains all studies)
        "root/Gallery/Studies": studies.map((s) => `Study:[//${s.id}]`),
        
        // L3 - About's children
        "root/About/Biography": ["This body of work experiments with a range of mediums, producing forms and situations that explore aesthetics, emotion, and identity across different contexts. The work moves fluidly between material, digital, spatial, and procedural approaches, without privileging a single format.", "Personal, cultural, and visual references are translated into form through abstraction and reduction. Narrative is avoided in favor of structure, texture, and composition."],
        "root/About/Statement": ["Often, things that seem stable turn out to depend on position, context, and relation. What feels fixed shifts when it is seen from another angle, placed somewhere else, or encountered at a different time. That instability is where this begins, not as something to solve, but as something to notice.", "Nothing here is meant to resolve that. The forms are not explanations. They leave space for things to feel unclear at first. Confusion is treated as a starting point rather than a problem, and curiosity is what follows. Meaning is not delivered in advance, but allowed to take shape through experience."],
        "root/About/Process": ["Work begins from a loose idea rather than a fixed plan. The idea establishes a direction, not an outcome. Decisions are made in response to what emerges during making rather than in advance.", "Forms are modified, removed, or discarded as they develop. Completion is not defined by criteria, but by a point at which further change no longer feels necessary."],
        
        // L3 - Contact's children
        "root/Contact/Social": ["Instagram->https://www.instagram.com/brandyura"],
        
        // L3 - Legal's children -> Info
        "root/Legal/Info": ["Rights + Usage", "Licensing", "Disclosures"],
        
        // L4 - Info's children
        "root/Legal/Info/Rights + Usage": ["All content on this website, including but not limited to images, text, video, and other media, is protected by copyright and remains the property of the artist unless otherwise stated.", "The content may be viewed for personal and informational purposes and may be shared by linking to this site. No content may be copied, reproduced, modified, distributed, transmitted, displayed, published, or used for any commercial or public purpose without prior written permission from the artist.", "Nothing on this website shall be construed as granting any license or right to use the content beyond personal viewing and linking."],
        "root/Legal/Info/Licensing": ["Licenses may be granted for limited purposes such as publication, exhibition, reproduction, editorial use, or other specific uses as agreed in writing. All licenses are non-exclusive, non-transferable, and apply only to the particular use approved. No license is implied by the presence of content on this website or by access to it.", "Requests for licensing must include a clear description of the intended use, context, duration, and distribution. Approval, modification, or denial of any request is at the sole discretion of the artist."],
        "root/Legal/Info/Disclosures": ["This website does not include sponsored content, paid placements, or third-party promotional material."],
      };

      // Generate study paths (now under Studies folder)
      studies.forEach((study) => {
        const studyKey = `root/Gallery/Studies/Study:[//${study.id}]`;
        struct[studyKey] = study.children;

        study.children.forEach((child) => {
          struct[`${studyKey}/${child}`] = ["Placeholder"];
        });
      });

      return struct;
    }

    const structure = buildStructure();

    const state: NavState = {
      path: ["root"],
      direction: null,
    };

    const nav = document.getElementById("folder-nav")!;
    let isAnimating = false;

    function isFolder(name: string, basePath: string): boolean {
      const fullPath = `${basePath}/${name}`;
      return structure.hasOwnProperty(fullPath) && name !== "Placeholder";
    }

    function getCurrentKey(): string {
      return state.path.join("/");
    }

    // Flash effect function - uses direct style manipulation
    function triggerFlashEffect(el: HTMLElement, callback: () => void): void {
      if (isAnimating) return;
      isAnimating = true;
      
      // Flash sequence: black (100%) -> white (0%) -> black (100%) -> pause -> navigate
      el.style.transition = 'opacity 70ms ease-out';
      el.style.opacity = '0';
      
      setTimeout(() => {
        // Fade back to black
        el.style.opacity = '1';
        
        setTimeout(() => {
          // Hold at 100% briefly before navigating
          el.style.transition = '';
          isAnimating = false;
          
          setTimeout(() => {
            callback();
          }, 50);
        }, 70);
      }, 70);
    }

    // Typewriter effect function - uses Date.now() to continue even when tab is inactive
    function typewriterEffect(el: HTMLElement, text: string, speed: number = 10): void {
      el.innerHTML = '';
      const startTime = Date.now();
      let lastCharCount = 0;
      
      const update = () => {
        const elapsed = Date.now() - startTime;
        const charsToShow = Math.min(Math.floor(elapsed / speed) + 1, text.length);
        
        if (charsToShow > lastCharCount) {
          // Add new characters with fade-in
          for (let i = lastCharCount; i < charsToShow; i++) {
            const span = document.createElement('span');
            span.textContent = text[i];
            span.style.opacity = '0';
            span.style.transition = 'opacity 150ms ease-out';
            el.appendChild(span);
            // Trigger reflow then fade in
            requestAnimationFrame(() => {
              span.style.opacity = '1';
            });
          }
          lastCharCount = charsToShow;
        }
        
        if (charsToShow < text.length) {
          setTimeout(update, speed);
        }
      };
      update();
    }

    // SVG symbols for tree structure
    function createBranchSvg(): SVGElement {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "1.2em");
      svg.setAttribute("height", "1.2em");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.style.verticalAlign = "middle";
      svg.style.marginRight = "0.3em";
      svg.style.flexShrink = "0";
      
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M8 0 V24 M8 12 H24");
      path.setAttribute("stroke", "currentColor");
      path.setAttribute("stroke-width", "1.75");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-linecap", "round");
      
      svg.appendChild(path);
      return svg;
    }
    
    function createLastBranchSvg(): SVGElement {
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
      svg.setAttribute("width", "1.2em");
      svg.setAttribute("height", "1.2em");
      svg.setAttribute("viewBox", "0 0 24 24");
      svg.style.verticalAlign = "middle";
      svg.style.marginRight = "0.3em";
      svg.style.flexShrink = "0";
      
      const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
      path.setAttribute("d", "M8 0 V12 H24");
      path.setAttribute("stroke", "currentColor");
      path.setAttribute("stroke-width", "1.75");
      path.setAttribute("fill", "none");
      path.setAttribute("stroke-linecap", "round");
      
      svg.appendChild(path);
      return svg;
    }

    function createItem(name: string, type: "folder" | "file" | "back", basePath?: string, isLast?: boolean, useTypewriter?: boolean): HTMLElement {
      const el = document.createElement("div");
      el.className = "folder-item";
      
      // Check if this is a link item (format: "Text->URL")
      const isLink = name.includes('->');
      let displayName = name;
      let linkUrl = '';
      
      if (isLink) {
        const parts = name.split('->');
        displayName = parts[0];
        linkUrl = parts[1];
      }
      
      el.dataset.name = displayName;
      el.dataset.type = type;
      if (basePath) el.dataset.basePath = basePath;

      // Base styles
      el.style.fontFamily = '"ABC Diatype", system-ui, sans-serif';
      el.style.fontSize = "clamp(12px, 2.5vw, 16px)";
      el.style.lineHeight = "1.2";
      el.style.padding = "4px 0";
      el.style.userSelect = "none";
      el.style.display = "inline-flex";
      el.style.alignItems = "flex-start";
      el.style.width = "fit-content";
      el.style.maxWidth = "80vw";

      if (type === "back") {
        el.textContent = '◁ Back';
        el.style.padding = "0 0 4px 0";
        el.style.marginBottom = "4px";
      } else if (useTypewriter) {
        // Add SVG symbol immediately, text will be typed after
        const svg = isLast ? createLastBranchSvg() : createBranchSvg();
        el.appendChild(svg);
        // Create a span for the typewriter text
        const textSpan = document.createElement("span");
        textSpan.className = "item-text";
        el.appendChild(textSpan);
      } else {
        // Add SVG symbol + text
        const svg = isLast ? createLastBranchSvg() : createBranchSvg();
        el.appendChild(svg);
        const textSpan = document.createElement("span");
        textSpan.className = "item-text";
        textSpan.textContent = displayName;
        el.appendChild(textSpan);
      }

      if (type === "folder" || type === "back") {
        el.classList.add(type);
        el.style.cursor = "pointer";
        
        el.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (isAnimating) return;
          
          if (type === "folder") {
            // Apply flash effect then navigate
            triggerFlashEffect(el, () => {
              handleClick(displayName, type, basePath);
            });
          } else {
            // Back button - no flash, navigate immediately
            handleClick(displayName, type, basePath);
          }
        });
      } else if (isLink) {
        // File with link - make it clickable
        el.classList.add('link');
        el.style.cursor = "pointer";
        
        el.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          
          if (isAnimating) return;
          
          // Apply flash effect then open link
          triggerFlashEffect(el, () => {
            window.open(linkUrl, '_blank');
          });
        });
      } else {
        el.style.cursor = "default";
      }

      return el;
    }

    function createHeader(name: string, isFirst: boolean): HTMLElement {
      const el = document.createElement("div");
      el.className = "folder-header";
      el.textContent = name;
      el.setAttribute("data-state", "entering");
      
      // Inline styles
      el.style.fontFamily = '"ABC Diatype", system-ui, sans-serif';
      el.style.fontSize = "clamp(12px, 2.5vw, 16px)";
      el.style.lineHeight = "1.2";
      el.style.padding = isFirst ? "0 0 4px 0" : "12px 0 4px 0";
      el.style.userSelect = "none";
      el.style.display = "inline-block";
      el.style.width = "fit-content";
      
      return el;
    }

    function clearItems(callback?: () => void): void {
      const items = Array.from(nav.querySelectorAll(".folder-item, .folder-header"));
      
      if (items.length === 0) {
        callback?.();
        return;
      }

      items.forEach((el) => {
        el.setAttribute("data-state", "exiting");
      });

      // Future: wait for animation here
      items.forEach((el) => el.remove());
      callback?.();
    }

    function renderItems(): void {
      const isHome = state.path.length === 1 && state.path[0] === "root";

      if (isHome) {
        // Home: L1 headers with L2 children
        const entries = Object.entries(l1Sections);
        entries.forEach(([l1Name, l2Items], sectionIndex) => {
          nav.appendChild(createHeader(l1Name, sectionIndex === 0));

          const basePath = `root/${l1Name}`;
          l2Items.forEach((name, index) => {
            const type = isFolder(name, basePath) ? "folder" : "file";
            const isLast = index === l2Items.length - 1;
            const el = createItem(name, type, basePath, isLast);
            el.setAttribute("data-state", "entering");
            nav.appendChild(el);
          });
        });
      } else {
        // Deeper: back + parent label + children
        const backEl = createItem("back", "back");
        backEl.setAttribute("data-state", "entering");
        nav.appendChild(backEl);

        // Parent label (current folder name)
        const parentName = state.path[state.path.length - 1];
        const parentEl = createHeader("└── " + parentName, true);
        parentEl.setAttribute("data-state", "entering");
        nav.appendChild(parentEl);

        const key = getCurrentKey();
        const items = structure[key] || [];

        items.forEach((name, index) => {
          const type = isFolder(name, key) ? "folder" : "file";
          const isLast = index === items.length - 1;
          const el = createItem(name, type, key, isLast, true);
          el.setAttribute("data-state", "entering");
          el.style.paddingLeft = "1em";
          el.style.display = "inline-flex";
          el.style.width = window.innerHeight > window.innerWidth ? "55vw" : "320px";
          el.style.maxWidth = "100%";
          el.style.whiteSpace = "normal";
          el.style.wordWrap = "break-word";
          el.style.wordBreak = "break-word";
          el.style.overflowWrap = "break-word";
          el.style.textAlign = "left";
          nav.appendChild(el);
          
          // Apply typewriter effect to text span only (SVG is already visible)
          const displayName = name.includes('->') ? name.split('->')[0] : name;
          
          // Check if we're in sections with longer text (needs faster speed)
          const isLegalInfo = key === "root/Legal/Info/Rights + Usage" || 
                             key === "root/Legal/Info/Licensing" || 
                             key === "root/Legal/Info/Disclosures";
          const isAboutSection = key === "root/About/Biography" ||
                                 key === "root/About/Statement" ||
                                 key === "root/About/Process";
          const speed = (isLegalInfo || isAboutSection) ? 2 : 5;
          
          // Calculate delay based on total length of all previous items
          let totalPreviousChars = 0;
          for (let i = 0; i < index; i++) {
            const prevName = items[i];
            const prevDisplayName = prevName.includes('->') ? prevName.split('->')[0] : prevName;
            totalPreviousChars += prevDisplayName.length;
          }
          const delay = totalPreviousChars * speed + (index * 100); // chars * speed + small gap between items
          
          setTimeout(() => {
            const textSpan = el.querySelector('.item-text') as HTMLElement;
            if (textSpan) {
              typewriterEffect(textSpan, displayName, speed);
            }
          }, delay);
        });
      }

      nav.querySelectorAll(".folder-item, .folder-header").forEach((el) => {
        el.setAttribute("data-state", "idle");
      });
    }

    function navigate(direction: "in" | "out", folder?: string, basePath?: string): void {
      state.direction = direction;

      if (direction === "in" && folder) {
        if (basePath && state.path.join("/") !== basePath) {
          state.path = basePath.split("/");
        }
        state.path.push(folder);
      } else if (direction === "out") {
        state.path.pop();
        // If we pop back to an L1 folder, go back to root
        if (state.path.length === 2 && state.path[0] === "root") {
          state.path = ["root"];
        }
      }

      clearItems(() => renderItems());
    }

    function handleClick(name: string, type: "folder" | "back", basePath?: string): void {
      if (type === "back") {
        navigate("out");
      } else if (type === "folder") {
        navigate("in", name, basePath);
      }
    }

    // Initial render
    renderItems();
  </script>

  <style>
    html, body {
      max-width: 100%;
      overflow: hidden !important;
      overscroll-behavior-x: none;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }

    html::-webkit-scrollbar,
    body::-webkit-scrollbar,
    *::-webkit-scrollbar {
      display: none !important;
      width: 0 !important;
      height: 0 !important;
    }

    * {
      box-sizing: border-box;
      max-width: 100%;
      scrollbar-width: none !important;
      -ms-overflow-style: none !important;
    }

    .hero {
      min-height: 100dvh;
      padding: clamp(100px, 15vh, 160px) 5vw clamp(16px, 4vh, calc(var(--corner-inset, 22px) + var(--corner-size, 28px)));
      display: flex;
      justify-content: center;
      align-items: flex-start;
      overflow-x: hidden;
    }

    .stack {
      width: min(1100px, 100%);
      padding-top: 2px;
    }

    #logo {
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-weight: 700;
      font-size: 28px;
      letter-spacing: -0.05em;
      line-height: 1;
      margin: 0 0 20px 0;
      text-align: left;
      text-rendering: geometricPrecision;
      user-select: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      pointer-events: none;
    }

    .logo-char {
      display: inline-block;
      width: 1.8em;
      text-align: center;
      vertical-align: baseline;
    }

    #folder-nav {
      margin-top: 20px;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 4px;
      overflow-y: auto;
      padding-bottom: 20px;
    }

    .folder-header {
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-size: clamp(14px, 3vw, 18px);
      padding: 20px 0 4px 0;
      opacity: 0.5;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      user-select: none;
    }

    .folder-header:first-child {
      padding-top: 0;
    }

    .folder-item {
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-size: clamp(18px, 4vw, 32px);
      padding: 4px 0;
      cursor: default;
      user-select: none;
    }

    .folder-item.folder,
    .folder-item.back,
    .folder-item.link {
      cursor: pointer;
    }

    .folder-item.folder:hover,
    .folder-item.back:hover,
    .folder-item.link:hover {
      opacity: 0.6;
    }

    .folder-item.back {
      opacity: 0.5;
      margin-bottom: 8px;
    }

    /* Animation-ready states */
    .folder-item[data-state="entering"] {}
    .folder-item[data-state="exiting"] {}
    .folder-item[data-state="idle"] {}
    .folder-header[data-state="entering"] {}
    .folder-header[data-state="exiting"] {}
    .folder-header[data-state="idle"] {}

    @media (max-width: 768px) {
      html, body {
        position: fixed;
        width: 100%;
        overflow: hidden;
        overscroll-behavior: none;
        -webkit-overflow-scrolling: touch;
        touch-action: pan-y;
      }

      .hero {
        padding-top: calc(80px + env(safe-area-inset-top, 0px));
        padding-bottom: 16px;
        padding-left: 8vw;
      }

      #folder-nav {
        margin-top: 20px;
      }

      #logo {
        font-size: clamp(22px, 6vw, 28px);
      }

      .folder-item {
        max-width: 80vw;
        word-break: break-word;
        overflow-wrap: break-word;
      }
    }

    /* Portrait orientation - wrap text sooner */
    @media (orientation: portrait) {
      .folder-item {
        max-width: 80vw;
      }
    }

    /* Landscape mobile - allow scrolling */
    @media (max-width: 932px) and (orientation: landscape) {
      html, body {
        position: relative !important;
        overflow-y: auto !important;
        height: auto;
        min-height: 100%;
      }

      .hero {
        min-height: auto;
        padding-top: 40px;
        padding-bottom: 40px;
        overflow: visible;
      }
    }
  </style>
</FrameLayout>