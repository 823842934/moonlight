---
const {
  title = "Brandyura",
  description = "Brandyura",
  ogImage = "/og.png",
} = Astro.props;

const siteUrl = "https://brandyura.com";
const canonical = new URL(Astro.url.pathname, siteUrl).toString();
const ogImageAbs = new URL(ogImage, siteUrl).toString();
---

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>{title}</title>


  <link rel="canonical" href={canonical} />
  <meta name="description" content={description} />

  <meta property="og:site_name" content="brandyura" />
  <meta property="og:type" content="website" />
  <meta property="og:title" content={title} />
  <meta property="og:description" content={description} />
  <meta property="og:url" content={canonical} />

  <meta property="og:image" content={ogImageAbs} />
  <meta property="og:image:width" content="960" />
  <meta property="og:image:height" content="960" />
  <meta property="og:image:type" content="image/png" />
  <meta property="og:image:alt" content="brandyura preview" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content={title} />
  <meta name="twitter:description" content={description} />
  <meta name="twitter:image" content={ogImageAbs} />

  <link rel="icon" href="/favicon.ico" />
  <link rel="preload" href="/fonts/ABCDiatype-Regular.woff" as="font" type="font/woff" crossorigin />
  <link rel="preload" href="/fonts/ABCDiatype-Bold.woff" as="font" type="font/woff" crossorigin />

  <style>
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Regular.woff") format("woff");
      font-weight: 400;
      font-style: normal;
      font-display: swap;
    }
    @font-face {
      font-family: "ABC Diatype";
      src: url("/fonts/ABCDiatype-Bold.woff") format("woff");
      font-weight: 700;
      font-style: normal;
      font-display: swap;
    }

    :root {
      --corner-inset: 22px;
      --corner-size: 28px;

      --intro-ms: 3000ms;
      --intro-ease: cubic-bezier(.2,.9,.2,1);
      --intro-blur: 18px;
      --intro-scale: 0.985;

      --cascade-ms: 420ms;
      --cascade-stagger: 80ms;
      --cascade-from-opacity: 0.25;
      --cascade-from-y: -10px;
      --cascade-from-blur: 1px;

      --intro-cascade-ms: 520ms;
      --intro-cascade-stagger: 90ms;
      --intro-cascade-from-opacity: 0;
      --intro-cascade-from-y: -10px;
      --intro-cascade-from-blur: 2px;

      --plus-ms: 520ms;
      --plus-ease: cubic-bezier(.22,.61,.36,1);
      --left-scale: 2.1;
      --right-scale: 0.45;
    }

    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      max-width: 100%;
      overflow: hidden !important;
      /* Hide scrollbar for Chrome, Safari and Opera */
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* IE and Edge */
    }

    html::-webkit-scrollbar,
    body::-webkit-scrollbar {
      display: none;
      width: 0 !important;
      height: 0 !important;
    }

    /* Hide scrollbars globally for all elements */
    * {
      scrollbar-width: none; /* Firefox */
      -ms-overflow-style: none;  /* IE and Edge */
    }

    *::-webkit-scrollbar {
      display: none;
      width: 0 !important;
      height: 0 !important;
    }

    body {
      font-family: "ABC Diatype", system-ui, sans-serif;
      color: #000000;
      overflow-x: clip;
    }

    /* background video */
    .bg-video {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 0;
      pointer-events: none;
      transform: translateY(30%) translateZ(0);
      object-fit: contain;
      object-position: center center;
      will-change: transform, filter;
      isolation: isolate;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      contain: layout style paint;
      opacity: 0;
      filter: blur(20px);
      animation: videoBlurIn 0.5s ease-out 1s forwards;
    }

    @keyframes videoBlurIn {
      from {
        filter: blur(20px);
        opacity: 0;
      }
      to {
        filter: blur(0);
        opacity: 1;
      }
    }

    /* Background blur when navigated into folders */
    .bg-video.is-blurred,
    .bg-fallback img.is-blurred {
      animation: none !important;
      filter: blur(12px) !important;
      opacity: 1 !important;
      transition: filter 0.4s ease-out;
    }
    .bg-video:not(.is-blurred),
    .bg-fallback img:not(.is-blurred) {
      transition: filter 0.4s ease-out;
    }

    /* Animated WebP fallback (always works; used on iOS) */
    .bg-fallback {
      position: fixed;
      inset: 0;
      width: 100%;
      height: 100%;
      background: #ffffff;
      z-index: 0;
      pointer-events: none;
      opacity: 0;
      transition: opacity 160ms linear;
      will-change: opacity;
      isolation: isolate;
      contain: layout style paint;
    }
    .bg-fallback img {
      width: 100%;
      height: 100%;
      display: block;
      object-fit: contain;
      object-position: center center;
      transform: translateY(30%) translateZ(0);
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      opacity: 0;
      filter: blur(20px);
      animation: videoBlurIn 0.5s ease-out 1s forwards;
    }

    /* Tall screens (phones) */
    @media (max-width: 640px) {
      .bg-video {
        object-fit: cover;
        object-position: center center;
      }
      .bg-fallback img {
        object-fit: cover;
        object-position: center center;
      }
    }

    /* Ultra-wide or landscape tablets/desktops */
    @media (min-aspect-ratio: 19/10) {
      .bg-video {
        object-fit: cover;
        object-position: center center;
      }
      .bg-fallback img {
        object-fit: cover;
        object-position: center center;
      }
    }

    /*
      iOS Safari can freeze background video after app switching.
      The only zero-UI, always-moving solution is: use WebP on iOS.
    */
    body.is-ios .bg-video { display: none !important; }
    body.is-ios .bg-fallback { opacity: 1; }

    .page-intro-wrap {
      position: relative;
      z-index: 1;
      min-height: 100%;
      transition:
        filter var(--intro-ms) var(--intro-ease),
        transform var(--intro-ms) var(--intro-ease);
      will-change: filter, transform;
    }

    .intro-wash {
      position: fixed;
      inset: 0;
      background: #ffffff;
      z-index: 9000;
      pointer-events: none;
      opacity: 0;
      transition: opacity var(--intro-ms) var(--intro-ease);
      will-change: opacity;
    }

    body.is-intro { overflow: hidden; }

    body.is-intro .page-intro-wrap {
      filter: blur(var(--intro-blur));
      transform: scale(var(--intro-scale));
      transform-origin: center;
    }

    body.is-intro .intro-wash { opacity: 1; }

    .corner-plus {
      position: fixed;
      z-index: 9999;
      font-family: "ABC Diatype", system-ui, sans-serif;
      font-weight: 700;
      font-size: var(--corner-size);
      line-height: 1;
      color: #000;
      user-select: none;
      pointer-events: none;
      transform-origin: center;
      will-change: transform, opacity;
      transform: rotate(0deg) scale(1);
      opacity: 1;
      transition:
        transform var(--plus-ms) var(--plus-ease),
        opacity var(--plus-ms) var(--plus-ease);
    }

    .corner-plus.tl { top: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.tr { top: var(--corner-inset); right: var(--corner-inset); }
    .corner-plus.bl { bottom: var(--corner-inset); left: var(--corner-inset); }
    .corner-plus.br { bottom: var(--corner-inset); right: var(--corner-inset); }

    body.plus-merged .corner-plus.tl,
    body.plus-merged .corner-plus.bl {
      transform: rotate(360deg) scale(var(--left-scale));
      opacity: 1;
    }

    body.plus-merged .corner-plus.tr,
    body.plus-merged .corner-plus.br {
      transform: rotate(360deg) scale(var(--right-scale));
      opacity: 0;
    }

    @keyframes studyCascadeIn {
      from {
        opacity: var(--cascade-from-opacity);
        transform: translateY(var(--cascade-from-y));
        filter: blur(var(--cascade-from-blur));
      }
      to {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    @keyframes introCascadeIn {
      from {
        opacity: var(--intro-cascade-from-opacity);
        transform: translateY(var(--intro-cascade-from-y));
        filter: blur(var(--intro-cascade-from-blur));
      }
      to {
        opacity: 1;
        transform: translateY(0);
        filter: blur(0);
      }
    }

    @media (prefers-reduced-motion: reduce) {
      :root {
        --intro-ms: 0ms;
        --cascade-ms: 0ms;
        --cascade-stagger: 0ms;
        --intro-cascade-ms: 0ms;
        --intro-cascade-stagger: 0ms;
        --plus-ms: 0ms;
      }
      .intro-wash { display: none; }
      .corner-plus { transition: none !important; }
      .bg-fallback { transition: none !important; }
    }
  </style>
</head>

<body class="is-intro">
  <video
    class="bg-video"
    autoplay
    muted
    loop
    playsinline
    webkit-playsinline
    preload="auto"
    aria-hidden="true"
    tabindex="-1"
  >
    <source src="/brandyura.mp4" type="video/mp4" />
  </video>

  <!-- iOS background: public/brandyura.webp -->
  <div class="bg-fallback" aria-hidden="true">
    <img src="/brandyura.webp" alt="" />
  </div>

  <div class="corner-plus tl">＋</div>
  <div class="corner-plus tr">＋</div>
  <div class="corner-plus bl">＋</div>
  <div class="corner-plus br">＋</div>

  <div class="intro-wash" aria-hidden="true"></div>

  <div class="page-intro-wrap">
    <slot />
  </div>

  <script is:inline>
    (() => {
      // Aggressive video playback protection
      const video = document.querySelector('.bg-video');
      if (video) {
        // Force video to stay playing
        const keepPlaying = () => {
          if (video.paused) {
            video.play().catch(() => {});
          }
        };

        // Monitor for any interruptions
        video.addEventListener('pause', keepPlaying);
        video.addEventListener('suspend', keepPlaying);
        
        // Check every animation frame
        let lastCheck = 0;
        const checkPlayback = (timestamp) => {
          if (timestamp - lastCheck > 100) { // Check every 100ms
            keepPlaying();
            lastCheck = timestamp;
          }
          requestAnimationFrame(checkPlayback);
        };
        requestAnimationFrame(checkPlayback);

        // Ensure video is on its own layer
        video.style.willChange = 'transform';
      }

      const root = document.documentElement;

      // iOS: always use WebP background (no freeze, no taps, no switching logic)
      const ua = navigator.userAgent || "";
      const isIOS = /iPhone|iPad|iPod/i.test(ua);
      if (isIOS) document.body.classList.add("is-ios");

      // study triggers (existing)
      const isStudyTrigger = (el) => {
        const v = el.getAttribute("data-study") || "";
        let val = v;
        try { val = decodeURIComponent(val); } catch {}
        val = val.trim().toLowerCase();
        return val.startsWith("study:") && val.includes("[//");
      };

      // NEW: node triggers (biography/statement/process/hello/social/placeholder)
      const isNodeTrigger = (el) => el && el.hasAttribute && el.hasAttribute("data-node");

      const isBackTrigger = (el) => {
        const txt = (el.textContent || "").trim().toLowerCase();
        return txt === "<- back" || txt === "← back" || txt === "back" || txt === "⟵ back";
      };

      const cssNum = (name, fallback) => {
        const raw = getComputedStyle(root).getPropertyValue(name).trim();
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      const cssMs = (name, fallback) => {
        const raw = getComputedStyle(root).getPropertyValue(name).trim();
        const n = parseFloat(raw);
        return Number.isFinite(n) ? n : fallback;
      };

      // Track navigation depth
      // 0 = gallery, 1 = study/node view (2nd level), 2+ = deeper levels
      let currentDepth = 0;

      // plus merge animation
      const merge = () => {
        // Only trigger animation if going from gallery (depth 0) to 2nd level (depth 1)
        if (currentDepth === 0) {
          // allow retrigger if user clicks different items quickly
          document.body.classList.remove("plus-merged");
          void document.body.offsetWidth;

          requestAnimationFrame(() => {
            requestAnimationFrame(() => {
              document.body.classList.add("plus-merged");
            });
          });
          
          currentDepth = 1;
        }
        // If already at depth 1 or deeper, don't re-trigger animation
      };

      const unmerge = () => {
        // Only unmerge when going back to gallery (depth 0)
        if (currentDepth === 1) {
          document.body.classList.remove("plus-merged");
          currentDepth = 0;
        }
      };

      const animateStudyListCascade = () => {
        const items = Array.from(document.querySelectorAll("[data-study]"))
          .filter((el) => el instanceof HTMLElement && isStudyTrigger(el));

        if (!items.length) return false;

        const stagger = cssNum("--cascade-stagger", 80);
        const ms = cssNum("--cascade-ms", 420);

        items.forEach((el, i) => {
          el.style.animation = "none";
          el.style.opacity = String(cssNum("--cascade-from-opacity", 0.25));
          el.style.transform = `translateY(${cssNum("--cascade-from-y", -10)}px)`;
          el.style.filter = `blur(${cssNum("--cascade-from-blur", 1)}px)`;

          void el.offsetWidth;

          const delay = i * stagger;
          el.style.animation = `studyCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

          el.addEventListener("animationend", () => {
            el.style.filter = "blur(0)";
          }, { once: true });
        });

        return true;
      };

      let didIntroCascade = false;

      const runIntroCascade = () => {
        if (didIntroCascade) return false;

        const items = Array.from(document.querySelectorAll("[data-intro-cascade]"))
          .filter((el) => el instanceof HTMLElement);

        if (!items.length) return false;

        didIntroCascade = true;

        const stagger = cssNum("--intro-cascade-stagger", 90);
        const ms = cssNum("--intro-cascade-ms", 520);

        items.forEach((el, i) => {
          el.style.animation = "none";
          el.style.opacity = "0";
          el.style.transform = `translateY(${cssNum("--intro-cascade-from-y", -10)}px)`;
          el.style.filter = `blur(${cssNum("--intro-cascade-from-blur", 2)}px)`;

          void el.offsetWidth;

          const delay = i * stagger;
          el.style.animation = `introCascadeIn ${ms}ms cubic-bezier(.25,.8,.25,1) ${delay}ms forwards`;

          el.addEventListener("animationend", () => {
            el.style.filter = "blur(0)";
          }, { once: true });
        });

        return true;
      };

      const runIntroCascadeWhenReady = () => {
        if (runIntroCascade()) return;

        const obs = new MutationObserver(() => {
          if (runIntroCascade()) obs.disconnect();
        });

        obs.observe(document.body, { childList: true, subtree: true });
        setTimeout(() => obs.disconnect(), 2000);
      };

      const triggerCascadeAfterBack = () => {
        if (animateStudyListCascade()) return;

        const obs = new MutationObserver(() => {
          if (animateStudyListCascade()) obs.disconnect();
        });

        obs.observe(document.body, { childList: true, subtree: true });
        setTimeout(() => obs.disconnect(), 1200);
      };

      document.addEventListener("click", (e) => {
        const target = e.target;
        if (!target || !target.closest) return;

        // Check if animation is in progress
        if (document.body.hasAttribute('data-is-animating')) {
          e.stopPropagation();
          e.preventDefault();
          return;
        }

        const studyEl = target.closest("[data-study]");
        if (studyEl && isStudyTrigger(studyEl)) {
          const link = studyEl.closest("a[href]");
          if (link) {
            e.preventDefault();
            const href = link.getAttribute("href");

            merge();

            const ms = cssMs("--plus-ms", 520);
            setTimeout(() => { window.location.href = href; }, Math.max(0, ms + 40));
          } else {
            merge();
          }
          return;
        }

        // NEW: apply same plus animation for any [data-node] click
        const nodeEl = target.closest("[data-node]");
        if (nodeEl && isNodeTrigger(nodeEl)) {
          merge();
          return;
        }

        const backEl = target.closest("button, a");
        if (backEl && isBackTrigger(backEl)) {
          unmerge();
          triggerCascadeAfterBack();
        }
      }, { capture: true });

      requestAnimationFrame(() => {
        requestAnimationFrame(() => {
          document.body.classList.remove("is-intro");
          window.runGalleryIntroCascadeOnce?.();

          requestAnimationFrame(() => {
            runIntroCascadeWhenReady();
          });
        });
      });

    })();
  </script>
</body>
</html>